<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta property="og:title" content="Algorithms by DasGupta, Part 2">
<meta property="og:description" content="Chapter 2: Divide-and-Conquer Algorithms The divide and conquer strategy solves a problem by
 Breaking it into sub-problems that are themselves smaller instances of the same type of problem. Recursively solving these problems. Appropriately combining their results.  Multiplication For multiplying two n-bit integers x and y.
$x = \bbox[5px, border:2px solid black]{ x_L } \quad \bbox[5px, border:2px solid black]{ x_R } = 2^{n/2}x_L + x_R$
$y = \bbox[5px, border:2px solid black]{ y_L } \quad \bbox[5px, border:2px solid black]{ y_R } = 2^{n/2}y_L + y_R$">
<meta property="og:type" content="article">
<meta property="og:url" content="https://nitishpuri.github.io/blog-hugo/books/programming/algorithms-dasgupta/algorithms2/"><meta property="og:image" content="https://nitishpuri.github.io/images/site-feature-image.jpg"><meta property="article:section" content="books">
<meta property="article:modified_time" content="2017-08-19T00:00:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://nitishpuri.github.io/images/site-feature-image.jpg">
<meta name=twitter:title content="Algorithms by DasGupta, Part 2">
<meta name=twitter:description content="Chapter 2: Divide-and-Conquer Algorithms The divide and conquer strategy solves a problem by
 Breaking it into sub-problems that are themselves smaller instances of the same type of problem. Recursively solving these problems. Appropriately combining their results.  Multiplication For multiplying two n-bit integers x and y.
$x = \bbox[5px, border:2px solid black]{ x_L } \quad \bbox[5px, border:2px solid black]{ x_R } = 2^{n/2}x_L + x_R$
$y = \bbox[5px, border:2px solid black]{ y_L } \quad \bbox[5px, border:2px solid black]{ y_R } = 2^{n/2}y_L + y_R$">
<link rel=canonical href=https://nitishpuri.github.io/blog-hugo/books/programming/algorithms-dasgupta/algorithms2/>
<title>
Algorithms by DasGupta, Part 2 | Blog - Nitish Puri
</title>
<link href=https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css rel=stylesheet integrity=sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1 crossorigin=anonymous>
<link href=../../../../blog-hugo/css/style.css rel=stylesheet>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}},window.addEventListener('load',a=>{document.querySelectorAll("mjx-container").forEach(function(a){a.parentElement.classList+='has-jax'})})</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<header class=blog-header>
<nav class="navbar navbar-expand-md navbar-light bg-light">
<div class=container-fluid>
<a class=navbar-brand href=../../../../blog-hugo>
<img src=https://getbootstrap.com/docs/4.1/assets/brand/bootstrap-solid.svg width=30 height=30 class="d-inline-block align-top" alt>
Blog - Nitish Puri
</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarNav aria-controls=navbarNav aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse justify-content-between" id=navbarNav>
<ul class=navbar-nav>
<li class=nav-item>
<a class=nav-link href=../../../../blog-hugo/blog-hugo/books/></a>
</li>
<li class=nav-item>
<a class=nav-link href=../../../../blog-hugo/blog-hugo/research/></a>
</li>
<li class=nav-item>
<a class=nav-link href=../../../../blog-hugo/blog-hugo/about/>About</a>
</li>
</ul>
</div>
</div>
</nav>
</header>
<div class=container>
<div class=row>
<div class="col-12 col-lg-8 blog-main"><nav class="breadcrumb container" aria-label=breadcrumb>
<ol class=breadcrumb>
<li class=breadcrumb-item> <a href=https://nitishpuri.github.io/blog-hugo/>Home</a> </li>
<li class=breadcrumb-item> <a href=https://nitishpuri.github.io/blog-hugo/books/>Books</a> </li>
<li class=breadcrumb-item> <a href=https://nitishpuri.github.io/blog-hugo/books/programming/>Programming</a> </li>
<li class=breadcrumb-item> <a href=https://nitishpuri.github.io/blog-hugo/books/programming/algorithms-dasgupta/>Algorithms by Das Gupta</a> </li>
<li class="breadcrumb-item active" aria-current=page> Algorithms by DasGupta, Part 2</li>
</ol>
</nav>
<header>
<h2 class=blog-post-title>
<a class="text-dark text-decoration-none" href=../../../../blog-hugo/books/programming/algorithms-dasgupta/algorithms2/>Algorithms by DasGupta, Part 2</a>
</h2>
<div class="blog-post-date text-secondary">
<time datetime=2017-08-19>Aug 19, 2017</time>
by <span rel=author>Nitish Puri</span>
</div>
<div class="blog-post-tags text-secondary">
<strong>Tags:</strong>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/algorithms>algorithms</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/notes>notes</a>
</div>
<hr>
</header>
<article class=blog-post>
<nav id=TableOfContents>
<ul>
<li><a href=#chapter-2-divide-and-conquer-algorithms>Chapter 2: Divide-and-Conquer Algorithms</a>
<ul>
<li><a href=#multiplication>Multiplication</a></li>
<li><a href=#recurrence-relations>Recurrence relations</a></li>
<li><a href=#mergesort>Mergesort</a></li>
<li><a href=#medians>Medians</a></li>
<li><a href=#matrix-multiplication>Matrix multiplication</a></li>
<li><a href=#fast-fourier-transform>Fast Fourier transform</a></li>
</ul>
</li>
</ul>
</nav>
<h2 id=chapter-2-divide-and-conquer-algorithms>Chapter 2: Divide-and-Conquer Algorithms</h2>
<p>The divide and conquer strategy solves a problem by</p>
<ol>
<li>Breaking it into sub-problems that are themselves smaller instances of the same type of problem.</li>
<li>Recursively solving these problems.</li>
<li>Appropriately combining their results.</li>
</ol>
<h3 id=multiplication>Multiplication</h3>
<p>For multiplying two n-bit integers x and y.<br>
$x = \bbox[5px, border:2px solid black]{ x_L } \quad \bbox[5px, border:2px solid black]{ x_R } = 2^{n/2}x_L + x_R$<br>
$y = \bbox[5px, border:2px solid black]{ y_L } \quad \bbox[5px, border:2px solid black]{ y_R } = 2^{n/2}y_L + y_R$</p>
<p>then,
$xy = (2^{n/2}x_L + x_R)(2^{n/2}y_L + y_R) = 2^nx_Ly_L + 2^{n/2}(x_Ly_R + x_Ry_L) + x_Ry_R$</p>
<p>Now, we can compute xy by evaluating the RHS. Addition and multiplication by $2^n$ are linear time. Rest of the 4 multiplications can be done by recursively applying this algorithm.</p>
<p>So, $T(n) = 4T(n/2) + O(n)$.</p>
<p>Which results in $O(n^2)$.</p>
<p>By expanding the middle term, we can do with just three calculations, $x_Ly_L , x_Ry_R, (x_L+x_R)(y_L+y_R)$.<br>
since,<br>
$x_Ly_R + x_Ry_L = (x_L + x_R ) (y_L + y_R ) - x_Ly_L â€“ x_Ry_R$.</p>
<p>Resulting algorithm would then be<br>
$T(n) = 3T(n/2) + O(n)$, which is $O(n^{1.59})$</p>
<p><img src=../../../../images/algdg/2_divide.png alt=alt></p>
<p>Height of the tree $= \log_2 n$, since the length of the sub-problem gets halved at every level.<br>
Branching factor = 3.</p>
<p>So, at any level k we will have $3^k$ to solve each of size $n/2^k$.</p>
<p>Therefore, time spent at level k is, $3^k \times O(\frac n {2^k}) = (\frac 3 2)^k \times O(n)$</p>
<p>Which is a geometric series. So, the sum then approximates to the last term of the series.<br>
That is $O(3^{\log_2 n})$, which can be written as $O(n^{\log_2 3})$, which is about $O(n^{1.59})$.</p>
<p>Can we do better ??? using <em>Fast Fourier Transforms</em> discussed later.</p>
<p><img src=../../../../images/algdg/2_dividemul.png alt=alt></p>
<h3 id=recurrence-relations>Recurrence relations</h3>
<p>Consider this recurrence tree.<br>
<img src=../../../../images/algdg/2_recur.png alt=alt></p>
<p><strong>Master&rsquo;s Theorem :</strong><br>
If $T(n) = aT(\lceil n/b \rceil) + O(n^d)$ for some constants $a > 0, b > 1$, and $d \ge 0$, then</p>
<p>$$ T(n) = \begin{cases}
O(n^d), \text{ if } d > \log_b a \
O(n^d\log n), \text{ if } d = \log_b a \<br>
O(n^{\log_b a}), \text{ if } d &lt; \log_b a
\end{cases}$$</p>
<p><img src=../../../../images/algdg/2_binary.png alt=alt></p>
<h3 id=mergesort>Mergesort</h3>
<p>Sort an array by recursively sorting each half and merging the results.<br>
<img src=../../../../images/algdg/2_merge.png alt=alt></p>
<p><img src=../../../../images/algdg/2_merge2.png alt=alt></p>
<p>Since merge does constant amount of work per recursive call, overall time is<br>
$$ T(n) = 2T(n/2) + O(n), \text{ or } O(n\log n)$$<br>
Here is an iterative version using a Queue.<br>
<img src=../../../../images/algdg/2_merge3.png alt=alt></p>
<h3 id=medians>Medians</h3>
<p>Median = 50th percentile of a list of numbers.<br>
<img src=../../../../images/algdg/2_medians.png alt=alt><br>
<em>A randomized divide-and-conquer algorithm for selection</em><br>
For any number <code>v</code>, Split <code>S</code> into three categories: elements smaller than <code>v</code> $(S_L)$, equal to <code>v</code> $(S_v)$ , greater than <code>v</code> $(S_R)$ , then
$$ selection(S, k) = \begin{cases}
selection(S_L, k), \quad\quad\quad\quad\quad\quad \text{if } k \le |S_L| \
v , \quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad \text{ if } |S_L| &lt; k \le |S_L| + |S_v| \<br>
selection(S_R, k - |S_L| - |S_v|), \text{ if } k > |S_L| + |S_v|
\end{cases}$$</p>
<p>The three sub-lists can be computed in linear time, even in place. <br>
How to pick <code>v</code> ? Randomly from <code>S</code>.<br>
<img src=../../../../images/algdg/2_unix.png alt=alt></p>
<h3 id=matrix-multiplication>Matrix multiplication</h3>
<p><img src=../../../../images/algdg/2_matmul.png alt=alt><br>
Symbolically,<br>
$$ Z_{ij} = \sum_{k=1}^n X_{ik}Y_{kj}$$</p>
<p>This implies the algorithm to be $O(n^3)$</p>
<p>Enter divide-and-conquer.<br>
Divide the matrices X and Y into 4 blocks.<br>
$$ X = \begin{bmatrix} A & B \ C & D \end{bmatrix}, Y = \begin{bmatrix}E & F \ G & H\end{bmatrix}
$$,</p>
<p>Then, their product can be expressed as,<br>
$$ XY = \begin{bmatrix}A & B \ C & D\end{bmatrix} =
\begin{bmatrix}AE+BG & AF+BH \ CE+DG & CF+DH \end{bmatrix} $$</p>
<p>Total running time can be described as,<br>
$T(n) = 8T(n/2) + O(n^2), \text{ which is again } O(n^3)$.</p>
<p>Turns out you can do this,<br>
$$ XY = \begin{bmatrix}P_5+P_4-P_2+P_6 & P_1+P_2 \ P_3+P_4 & P_1+P_5-P_3-P_7\end{bmatrix} $$</p>
<p>where,<br>
$P_1 = A(F-H) \quad\quad P_5 = (A+D)(E+H)$<br>
$P_2 = (A+B)H \quad\quad P_6 = (B-D)(G+H)$<br>
$P_3 = (C+D)E \quad\quad P_7 = (A-C)(E+F)$<br>
$P_4 = D(G-E)$</p>
<p>The new running time is, $T(n) = 7T(n/2) + O(n^2), \text{which is } O(n^{\log_2 7}) \approx O(n^{2.81})$</p>
<h3 id=fast-fourier-transform>Fast Fourier transform</h3>
<p>Next target, <em>Polynomials</em>.</p>
<p>The general solution for polynomial multiplication works in $\theta(d^2)$ time, where $d$ is the degree of polynomials.</p>
<p><em>An alternative representation of polynomials.</em></p>
<p><strong>Fact</strong> : <em>A degree-d polynomial is uniquely characterized by its values at any $d+1$ distinct points</em>.</p>
<p>So, we can specify a degree-d polynomial $$A(x) = a_0+a_1x+&mldr;+a_dx^d$$ by any one of the following,</p>
<ol>
<li>Its coefficients, $a_0, a_1,&mldr;, a_d$</li>
<li>The values $A(x_0), A(x_1), &mldr;, A(x_d)$</li>
</ol>
<p>Now, taking in consideration the second form, the product has a degree $2d$, and is completely determined by its values at $2d+1$ points.<br>
Since, those values are just products of the two polynomials at the given point. Thus, polynomial multiplication takes linear time in the value representation.<br>
<img src=../../../../images/algdg/2_poly1.png alt=alt><br>
<img src=../../../../images/algdg/2_poly2.png alt=alt></p>
<p><em>Evaluation by divide-and-conquer</em><br>
<strong>The Trick</strong> : Choose the n points to be selected as positive-negative pairs, then the computations needed to be done overlap a lot.<br>
Specifically,<br>
<img src=../../../../images/algdg/2_eval.png alt=alt><br>
if we could then recurse, we would have,<br>
$$T(n) = 2T(n/2) + O(n), \text{which is } O(n\log n)$$<br>
But, recursing it at the second level and beyond seems impossible. Unless, of-course we use complex numbers.<br>
To get positive-negative pairs at subsequent levels, we can use the roots of $z^n = 1$<br>
Which are, $1, \omega, \omega^2, &mldr; \omega^{n-1}, \text{ where, } \omega = e^{2\pi i/n}$</p>
<p>So, if we choose these numbers, at every successive level of recursion we have pairs of positive-negative numbers<br>
<img src=../../../../images/algdg/2_fft2.png alt=alt></p>
<p><strong>Interpolation</strong><br>
$$\langle \text{values} \rangle = FFT(\langle \text{coefficients} \rangle, \omega)$$, and<br>
$$\langle \text{coefficients} \rangle = \frac 1 n FFT(\langle \text{values} \rangle, \omega^{-1}) $$</p>
<p>Details left,, See <em>Fourier basis</em></p>
<p><strong>A closer look at the fast Fourier Transform</strong><br>
The FFT takes as input a vector $a = (a_0, &mldr; a_{n-1})$ and a complex number $\omega$ whose powers are the complex root of unity.<br>
It multiplies this vector with the Matrix $M_n(\omega)$, which has $(j, k)_{th}$ entry (starting row and column count at zero) $\omega^{jk}$.
<img src=../../../../images/algdg/2_fft3.png alt=alt><br>
<img src=../../../../images/algdg/2_fft4.png alt=alt></p>
<footer>
<h4>See also</h4>
<ul>
<li><a href=../../../../blog-hugo/books/programming/algorithms-design-manual/algorithms-design-manual8/>The Algorithms Design Manual, Set and String Problems</a></li>
<li><a href=../../../../blog-hugo/books/programming/algorithms-design-manual/algorithms-design-manual7/>The Algorithms Design Manual, Computational Geometry</a></li>
<li><a href=../../../../blog-hugo/books/programming/algorithms-design-manual/algorithms-design-manual6/>The Algorithms Design Manual, Graph Problems(Hard Problems)</a></li>
<li><a href=../../../../blog-hugo/books/programming/algorithms-design-manual/algorithms-design-manual5/>The Algorithms Design Manual, Graph Problems(Polynomial-Time)</a></li>
<li><a href=../../../../blog-hugo/books/programming/algorithms-dasgupta/algorithms3/>Algorithms by DasGupta, Part 3</a></li>
</ul>
</footer>
</article>
</div>
<aside class="col-12 col-lg-3 ml-auto blog-sidebar">
<section>
<h4>Recent Posts</h4>
<ol class=list-unstyled>
<li>
<a href=../../../../blog-hugo/books/programming/the-little-schemer/>The Little Schemer</a>
</li>
<li>
<a href=../../../../blog-hugo/books/programming/game-engine-architecture/>Game Engine Architecture</a>
</li>
<li>
<a href=../../../../blog-hugo/books/programming/neuralnets/neural-networks-and-deep-learning-7/>Is there a simple algorithm for intelligence?, Micheal Nelson</a>
</li>
<li>
<a href=../../../../blog-hugo/books/programming/neuralnets/neural-networks-and-deep-learning-6/>Deep Learning, Micheal Nelson</a>
</li>
<li>
<a href=../../../../blog-hugo/books/programming/neuralnets/neural-networks-and-deep-learning-5/>Why are deep neural networks hard to train?, Micheal Nelson</a>
</li>
</ol>
</section>
<section>
<h4>Categories</h4>
<p>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/categories/books>books</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/categories/courses>courses</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/categories/machine-intelligence>machine-intelligence</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/categories/notes>notes</a>
</p>
<h4>Tags</h4>
<p>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/algorithms>algorithms</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/architecture>architecture</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/biorobots>biorobots</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/book>book</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/data-science>data-science</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/deep-learning>deep-learning</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/design>design</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/game-engine>game-engine</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/graphics>graphics</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/image-segmentation>image-segmentation</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/kuka>kuka</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/lisp>lisp</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/machine-intelligence>machine-intelligence</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/notes>notes</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/opengl>opengl</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/philosophy>philosophy</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/programming>programming</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/projects>projects</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/robotics>robotics</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/scheme>scheme</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/style-transfer>style-transfer</a>
<a class="btn btn-primary btn-small badge" href=../../../../blog-hugo/tags/udacity>udacity</a>
</p>
</section>
</aside>
</div>
</div>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js integrity=sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW crossorigin=anonymous></script>
</body>
</html>